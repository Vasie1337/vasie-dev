name: Build and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_REGISTRY: docker.io
  CONFIG_FILE: .github/build-config.json

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.parse-config.outputs.services }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Parse build configuration
      id: parse-config
      run: |
        # Read the config file and output as JSON
        CONFIG=$(cat ${{ env.CONFIG_FILE }})
        echo "services=$(echo $CONFIG | jq -c '.services')" >> $GITHUB_OUTPUT

  build-and-push:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services) }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set lowercase values
      id: lowercase
      run: |
        # Convert owner name to lowercase
        OWNER_LOWERCASE=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
        REPO_NAME=$(echo "${{ github.repository }}" | cut -d '/' -f 2 | tr '[:upper:]' '[:lower:]')
        echo "owner=$OWNER_LOWERCASE" >> $GITHUB_OUTPUT
        echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
    
    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service.name }}
        tags: |
          type=sha
          latest
    
    - name: Build and push Docker image for ${{ matrix.service.name }}
      uses: docker/build-push-action@v4
      with:
        context: ${{ matrix.service.context }}
        file: ${{ matrix.service.dockerfile }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=${{ matrix.service.name }}
        cache-to: type=gha,mode=max,scope=${{ matrix.service.name }}
        secrets: |
          "github_token=${{ secrets.GITHUB_TOKEN }}"
        build-args: |
          GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set lowercase values
      id: lowercase
      run: |
        # Extract repository name without owner and convert to lowercase
        REPO_NAME=$(echo "${{ github.repository }}" | cut -d '/' -f 2 | tr '[:upper:]' '[:lower:]')
        DOCKER_USERNAME=$(echo "${{ secrets.DOCKER_USERNAME }}" | tr '[:upper:]' '[:lower:]')
        echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
        echo "docker_username=$DOCKER_USERNAME" >> $GITHUB_OUTPUT
    
    - name: Set project directory name
      id: project-dir
      run: |
        # Use lowercase repository name for the directory
        echo "dir_name=${{ steps.lowercase.outputs.repo_name }}" >> $GITHUB_OUTPUT
    
    - name: Set up SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.VPS_IP }} >> ~/.ssh/known_hosts
    
    - name: Create .env file for deployment
      run: |
        cat > .env << EOF
        DOCKER_USERNAME=${{ steps.lowercase.outputs.docker_username }}
        PROJECT_NAME=${{ steps.lowercase.outputs.repo_name }}
        IMAGE_TAG=sha-${{ github.sha }}
        INSTANCE_NAME=${{ steps.lowercase.outputs.repo_name }}
        ENVIRONMENT=production
        CLOUDFLARE_TUNNEL_TOKEN=${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        EOF
    
    - name: Update docker-compose.yml to use portfolio service
      run: |
        # Ensure docker-compose uses the portfolio service
        # This step runs before updating the image tag
        if grep -q "services:" docker-compose.yml && grep -q "app:" docker-compose.yml; then
          sed -i 's/  app:/  portfolio:/g' docker-compose.yml
        fi

        # Add ports if they don't exist
        if ! grep -q "ports:" docker-compose.yml; then
          sed -i '/restart: always/a\    ports:\n      - "3000:3000"' docker-compose.yml
        fi
    
    - name: Update docker-compose with new image tags
      run: |
        # Parse build config
        CONFIG=$(cat ${{ env.CONFIG_FILE }})
        
        # Create a temporary script to update docker-compose
        cat > update-compose.sh << 'EOF'
        #!/bin/bash
        
        # Get the services from build-config.json
        SERVICES=$(cat .github/build-config.json | jq -c '.services[]')
        
        # Process each service
        echo "$SERVICES" | while read -r service; do
          # Extract service name from build-config.json
          NAME=$(echo "$service" | jq -r '.name')
          
          # Use proper Docker Hub format: username/repository:tag
          IMAGE_TAG="${DOCKER_USERNAME}/${NAME}:sha-${GITHUB_SHA}"
          
          # Use yq to update the docker-compose.yml (install if necessary)
          if ! command -v yq &> /dev/null; then
            wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            chmod +x /usr/local/bin/yq
          fi
          
          # Update the image for this service
          yq -i ".services.$NAME.image = \"$IMAGE_TAG\"" docker-compose.yml
          
          # Verify if the update was successful
          echo "Updated service $NAME with image: $IMAGE_TAG"
          grep -A 2 "$NAME:" docker-compose.yml
        done
        EOF
        
        chmod +x update-compose.sh
        sudo apt-get update && sudo apt-get install -y wget
        DOCKER_USERNAME="${{ steps.lowercase.outputs.docker_username }}" GITHUB_SHA="${{ github.sha }}" ./update-compose.sh
        
        # Print the updated docker-compose.yml for debugging
        echo "Final docker-compose.yml:"
        cat docker-compose.yml
    
    - name: Create project directory on VPS
      run: |
        ssh -i ~/.ssh/id_rsa -t ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }} "mkdir -p ~/${{ steps.project-dir.outputs.dir_name }}"
    
    - name: Copy files to VPS
      run: |
        scp -i ~/.ssh/id_rsa docker-compose.yml ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }}:~/${{ steps.project-dir.outputs.dir_name }}/
        scp -i ~/.ssh/id_rsa .env ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }}:~/${{ steps.project-dir.outputs.dir_name }}/.env
        
        # Copy any additional config files if specified
        if [ -d "config" ]; then
          scp -i ~/.ssh/id_rsa -r config ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }}:~/${{ steps.project-dir.outputs.dir_name }}/
        fi
    
    - name: Deploy on VPS
      run: |
        # Create and run a deployment script on the remote server
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Go to the project directory
        cd ~/$1
        
        # Print environment and docker-compose for debugging
        echo "Environment variables:"
        cat .env
        
        echo "Docker compose file:"
        cat docker-compose.yml
        
        # Pull all the latest images
        docker compose pull
        
        # Stop existing containers
        docker compose down
        
        # Start new containers
        docker compose up -d
        
        # Clean up old images
        docker image prune -f
        
        # Show running containers
        docker compose ps
        
        # Show logs
        docker compose logs --tail=20
        EOF
        
        chmod +x deploy.sh
        scp -i ~/.ssh/id_rsa deploy.sh ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }}:~/deploy.sh
        ssh -i ~/.ssh/id_rsa -t ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }} "bash ~/deploy.sh ${{ steps.project-dir.outputs.dir_name }}"
    
    - name: Verify deployment
      run: |
        ssh -i ~/.ssh/id_rsa -t ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }} "cd ~/${{ steps.project-dir.outputs.dir_name }} && docker compose ps && docker compose logs --tail=20"